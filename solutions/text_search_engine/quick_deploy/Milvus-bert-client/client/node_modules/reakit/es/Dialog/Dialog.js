import { createComponent } from 'reakit-system/createComponent';
import { createHook } from 'reakit-system/createHook';
import '../Box/Box.js';
import { a as _objectWithoutPropertiesLoose, _ as _objectSpread2 } from '../_rollupPluginBabelHelpers-ce04ac6e.js';
import { useRef, useEffect, createContext, useContext, useState, useCallback, useMemo, createElement } from 'react';
import { useForkRef } from 'reakit-utils/useForkRef';
import { getFirstTabbableIn, ensureFocus, getLastTabbableIn, isTabbable } from 'reakit-utils/tabbable';
import { hasFocusWithin } from 'reakit-utils/hasFocusWithin';
import { warning, useWarning } from 'reakit-warning';
import { useAllCallbacks } from 'reakit-utils/useAllCallbacks';
import 'reakit-utils/useSealedState';
import { useCreateElement } from 'reakit-system/useCreateElement';
import '../Id/IdProvider.js';
import '../Id/IdState.js';
import '../Id/IdGroup.js';
import { useIsomorphicEffect } from 'reakit-utils/useIsomorphicEffect';
import { getDocument } from 'reakit-utils/getDocument';
import { useLiveRef } from 'reakit-utils/useLiveRef';
import { usePipe } from 'reakit-utils/usePipe';
import 'reakit-utils/cx';
import '../Disclosure/DisclosureState.js';
import { useDisclosureContent } from '../Disclosure/DisclosureContent.js';
import 'react-dom';
import { Portal } from '../Portal/Portal.js';
import { disableBodyScroll, enableBodyScroll } from 'body-scroll-lock';
import { useUpdateEffect } from 'reakit-utils/useUpdateEffect';
import { closest } from 'reakit-utils/closest';
import { getActiveElement } from 'reakit-utils/getActiveElement';
import { removeItemFromArray } from 'reakit-utils/removeItemFromArray';
import { useDialogState } from './DialogState.js';
import { D as DialogBackdropContext } from '../DialogBackdropContext-dd59a293.js';

function useActiveElementRef(dialogRef, options) {
  var activeElementRef = useRef(null);
  useIsomorphicEffect(function () {
    if (options.visible) return undefined;
    var document = getDocument(dialogRef.current);

    var onFocus = function onFocus(event) {
      var target = event.target;
      activeElementRef.current = target;
    };

    document.addEventListener("focus", onFocus, true);
    return function () {
      return document.removeEventListener("focus", onFocus, true);
    };
  }, [options.visible, dialogRef]);
  return activeElementRef;
}

function useDisclosuresRef(dialogRef, options) {
  var disclosuresRef = useRef([]);
  var activeElementRef = useActiveElementRef(dialogRef, options);
  useEffect(function () {
    if (!options.visible) return;
    var document = getDocument(dialogRef.current);
    var selector = "[aria-controls~=\"" + options.baseId + "\"]";
    var disclosures = Array.from(document.querySelectorAll(selector));

    if (activeElementRef.current instanceof HTMLElement) {
      if (disclosures.indexOf(activeElementRef.current) !== -1) {
        var withoutActiveElement = disclosures.filter(function (disclosure) {
          return disclosure !== activeElementRef.current;
        });
        disclosuresRef.current = [activeElementRef.current].concat(withoutActiveElement);
      } else {
        disclosuresRef.current = [activeElementRef.current].concat(disclosures);
      }
    } else {
      disclosuresRef.current = disclosures;
    }
  }, [options.visible, dialogRef, options.baseId]);
  return disclosuresRef;
}

function usePreventBodyScroll(targetRef, options) {
  var shouldPrevent = Boolean(options.preventBodyScroll && options.visible);
  useEffect(function () {
    var element = targetRef.current;
    if (!element || !shouldPrevent) return undefined;
    disableBodyScroll(element, {
      reserveScrollBarGap: true
    });
    return function () {
      return enableBodyScroll(element);
    };
  }, [targetRef, shouldPrevent]);
}

function useFocusOnShow(dialogRef, nestedDialogs, options) {
  var initialFocusRef = options.unstable_initialFocusRef;
  var shouldFocus = options.visible && options.unstable_autoFocusOnShow;
  useUpdateEffect(function () {
    var dialog = dialogRef.current;
    process.env.NODE_ENV !== "production" ? warning(Boolean(shouldFocus && !dialog), "[reakit/Dialog]", "Can't set initial focus on dialog because `ref` wasn't passed to component.", "See https://reakit.io/docs/dialog") : void 0; // If there're nested open dialogs, let them handle focus

    if (!shouldFocus || !dialog || nestedDialogs.find(function (child) {
      return Boolean(child.current && !child.current.hidden);
    })) {
      return;
    }

    if (initialFocusRef && initialFocusRef.current) {
      initialFocusRef.current.focus({
        preventScroll: true
      });
    } else {
      var tabbable = getFirstTabbableIn(dialog, true);

      var isActive = function isActive() {
        return hasFocusWithin(dialog);
      };

      if (tabbable) {
        ensureFocus(tabbable, {
          preventScroll: true,
          isActive: isActive
        });
      } else {
        ensureFocus(dialog, {
          preventScroll: true,
          isActive: isActive
        });
        process.env.NODE_ENV !== "production" ? warning(dialog.tabIndex === undefined || dialog.tabIndex < 0, "It's recommended to have at least one tabbable element inside dialog. The dialog element has been automatically focused.", "If this is the intended behavior, pass `tabIndex={0}` to the dialog element to disable this warning.", "See https://reakit.io/docs/dialog/#initial-focus", dialog) : void 0;
      }
    }
  }, [dialogRef, nestedDialogs, initialFocusRef, shouldFocus]);
}

function usePortalRef(dialogRef, options) {
  var portalRef = useRef(null);
  useEffect(function () {
    var dialog = dialogRef.current;
    if (!dialog || !options.visible) return;
    portalRef.current = closest(dialog, Portal.__selector);
  }, [dialogRef, options.visible]);
  return portalRef;
}

function removeFromDOM(element) {
  if (element.parentNode == null) return;
  element.parentNode.removeChild(element);
}

function hasNestedOpenModals(nestedDialogs) {
  return nestedDialogs.find(function (dialog) {
    return Boolean(dialog.current && !dialog.current.hidden && dialog.current.getAttribute("aria-modal") === "true");
  });
}

var focusTrapClassName = "__reakit-focus-trap";
function isFocusTrap(element) {
  var _element$classList;

  return (_element$classList = element.classList) === null || _element$classList === void 0 ? void 0 : _element$classList.contains(focusTrapClassName);
}
function useFocusTrap(dialogRef, nestedDialogs, options) {
  var portalRef = usePortalRef(dialogRef, options);
  var shouldTrap = options.visible && options.modal;
  var beforeElement = useRef(null);
  var afterElement = useRef(null); // Create before and after elements
  // https://github.com/w3c/aria-practices/issues/545

  useEffect(function () {
    if (!shouldTrap) return undefined;
    var portal = portalRef.current;

    if (!portal) {
      process.env.NODE_ENV !== "production" ? warning(true, "Can't trap focus within modal dialog because either `ref` wasn't passed to component or the component wasn't rendered within a portal", "See https://reakit.io/docs/dialog") : void 0;
      return undefined;
    }

    if (!beforeElement.current) {
      beforeElement.current = document.createElement("div");
      beforeElement.current.className = focusTrapClassName;
      beforeElement.current.tabIndex = 0;
      beforeElement.current.style.position = "fixed";
      beforeElement.current.setAttribute("aria-hidden", "true");
    }

    if (!afterElement.current) {
      afterElement.current = beforeElement.current.cloneNode();
    }

    portal.insertAdjacentElement("beforebegin", beforeElement.current);
    portal.insertAdjacentElement("afterend", afterElement.current);
    return function () {
      if (beforeElement.current) removeFromDOM(beforeElement.current);
      if (afterElement.current) removeFromDOM(afterElement.current);
    };
  }, [portalRef, shouldTrap]); // Focus trap

  useEffect(function () {
    var before = beforeElement.current;
    var after = afterElement.current;
    if (!shouldTrap || !before || !after) return undefined;

    var handleFocus = function handleFocus(event) {
      var dialog = dialogRef.current;
      if (!dialog || hasNestedOpenModals(nestedDialogs)) return;
      event.preventDefault();
      var isAfter = event.target === after;
      var tabbable = isAfter ? getFirstTabbableIn(dialog) : getLastTabbableIn(dialog);

      if (tabbable) {
        tabbable.focus();
      } else {
        // fallback to dialog
        dialog.focus();
      }
    };

    before.addEventListener("focus", handleFocus);
    after.addEventListener("focus", handleFocus);
    return function () {
      before.removeEventListener("focus", handleFocus);
      after.removeEventListener("focus", handleFocus);
    };
  }, [dialogRef, nestedDialogs, shouldTrap]); // Click trap

  useEffect(function () {
    if (!shouldTrap) return undefined;
    var document = getDocument(dialogRef.current);

    var handleClick = function handleClick() {
      var dialog = dialogRef.current;
      var portal = portalRef.current;
      if (!dialog || !portal || hasNestedOpenModals(nestedDialogs)) return;

      if (!hasFocusWithin(portal)) {
        dialog.focus();
      }
    };

    document.addEventListener("click", handleClick);
    return function () {
      document.removeEventListener("click", handleClick);
    };
  }, [dialogRef, nestedDialogs, portalRef, shouldTrap]);
}

function hidByFocusingAnotherElement(dialogRef) {
  var dialog = dialogRef.current;
  if (!dialog) return false;
  var activeElement = getActiveElement(dialog);
  if (!activeElement) return false;
  if (dialog.contains(activeElement)) return false;
  if (isTabbable(activeElement)) return true;
  if (activeElement.getAttribute("data-dialog") === "true") return true;
  return false;
}

function useFocusOnHide(dialogRef, disclosuresRef, options) {
  var shouldFocus = options.unstable_autoFocusOnHide && !options.visible;
  useUpdateEffect(function () {
    if (!shouldFocus) return; // Hide was triggered by a click/focus on a tabbable element outside
    // the dialog or on another dialog. We won't change focus then.

    if (hidByFocusingAnotherElement(dialogRef)) {
      return;
    }

    var finalFocusEl = options.unstable_finalFocusRef && options.unstable_finalFocusRef.current || disclosuresRef.current && disclosuresRef.current[0];

    if (finalFocusEl) {
      ensureFocus(finalFocusEl);
    } else {
      process.env.NODE_ENV !== "production" ? warning(true, "Can't return focus after closing dialog. Either render a disclosure component or provide a `unstable_finalFocusRef` prop.", "See https://reakit.io/docs/dialog", dialogRef.current) : void 0;
    }
  }, [dialogRef, disclosuresRef, shouldFocus]);
}

var DialogContext = createContext({});
function useNestedDialogs(dialogRef, options) {
  var context = useContext(DialogContext);

  var _React$useState = useState([]),
      dialogs = _React$useState[0],
      setDialogs = _React$useState[1];

  var addDialog = useCallback(function (ref) {
    if (context.addDialog) {
      context.addDialog(ref);
    }

    setDialogs(function (refs) {
      return [].concat(refs, [ref]);
    });
  }, [context.addDialog]);
  var removeDialog = useCallback(function (ref) {
    if (context.removeDialog) {
      context.removeDialog(ref);
    }

    setDialogs(function (refs) {
      return removeItemFromArray(refs, ref);
    });
  }, [context.removeDialog]); // If it's a nested dialog, add it to context

  useEffect(function () {
    if (!context.addDialog || options.unstable_orphan) return undefined;
    context.addDialog(dialogRef);
    return function () {
      if (context.removeDialog) {
        context.removeDialog(dialogRef);
      }
    };
  }, [dialogRef, context.addDialog, context.removeDialog, options.unstable_orphan]); // Close all nested dialogs when parent dialog closes

  useEffect(function () {
    if (context.visible === false && options.visible && options.hide && !options.unstable_orphan) {
      options.hide();
    }
  }, [context.visible, options.visible, options.hide, options.unstable_orphan]); // Provider

  var providerValue = useMemo(function () {
    return {
      visible: options.visible,
      addDialog: addDialog,
      removeDialog: removeDialog
    };
  }, [options.visible, addDialog, removeDialog]);
  var wrap = useCallback(function (element) {
    return createElement(DialogContext.Provider, {
      value: providerValue
    }, element);
  }, [providerValue]);
  return {
    dialogs: dialogs,
    wrap: wrap
  };
}

function dialogContains(target) {
  return function (dialog) {
    if (!dialog.current) return false;

    if (dialog.current.contains(target)) {
      return true;
    }

    var document = getDocument(dialog.current);
    var backdrop = document.querySelector("[data-dialog-ref=\"" + dialog.current.id + "\"]");

    if (backdrop) {
      return backdrop.contains(target);
    }

    return false;
  };
}

function isDisclosure(target) {
  return function (disclosure) {
    if (disclosure.contains(target)) {
      return true;
    }

    return disclosure.id && disclosure.id === target.getAttribute("aria-activedescendant");
  };
}

function useEventListenerOutside(containerRef, disclosuresRef, nestedDialogs, eventType, listener, shouldListen) {
  var listenerRef = useLiveRef(listener);
  useEffect(function () {
    if (!shouldListen) return undefined;

    var handleEvent = function handleEvent(event) {
      if (!listenerRef.current) return;
      var container = containerRef.current;
      var disclosures = disclosuresRef.current || [];
      var target = event.target;

      if (!container) {
        process.env.NODE_ENV !== "production" ? warning(true, "Can't detect events outside dialog because `ref` wasn't passed to component.", "See https://reakit.io/docs/dialog") : void 0;
        return;
      } // Click inside dialog


      if (container.contains(target)) return; // Click on disclosure

      if (disclosures.length && disclosures.some(isDisclosure(target))) {
        return;
      } // Click inside a nested dialog or focus trap


      if (isFocusTrap(target) || nestedDialogs.find(dialogContains(target))) {
        return;
      }

      listenerRef.current(event);
    };

    var document = getDocument(containerRef.current);
    document.addEventListener(eventType, handleEvent, true);
    return function () {
      document.removeEventListener(eventType, handleEvent, true);
    };
  }, [containerRef, disclosuresRef, nestedDialogs, eventType, shouldListen, listenerRef]);
}

function useMouseDownRef(dialogRef, options) {
  var mouseDownRef = useRef();
  useEffect(function () {
    if (!options.visible || !options.hideOnClickOutside) {
      return undefined;
    }

    var document = getDocument(dialogRef.current);

    var onMouseDown = function onMouseDown(event) {
      mouseDownRef.current = event.target;
    };

    document.addEventListener("mousedown", onMouseDown);
    return function () {
      document.removeEventListener("mousedown", onMouseDown);
    };
  }, [options.visible, options.hideOnClickOutside, dialogRef]);
  return mouseDownRef;
}

function useHideOnClickOutside(dialogRef, disclosuresRef, nestedDialogs, options) {
  var mouseDownRef = useMouseDownRef(dialogRef, options);
  useEventListenerOutside(dialogRef, disclosuresRef, nestedDialogs, "click", function (event) {
    // Make sure the element that has been clicked is the same that last
    // triggered the mousedown event. This prevents the dialog from closing
    // by dragging the cursor (for example, selecting some text inside the
    // dialog and releasing the mouse outside of it).
    if (mouseDownRef.current === event.target && options.hide) {
      options.hide();
    }
  }, options.visible && options.hideOnClickOutside);
  useEventListenerOutside(dialogRef, disclosuresRef, nestedDialogs, "focus", options.hide, options.visible && options.hideOnClickOutside);
}

function useDisableHoverOutside(portalRef, nestedDialogs, options) {
  var useEvent = function useEvent(eventType) {
    return useEventListenerOutside(portalRef, {
      current: null
    }, nestedDialogs, eventType, function (event) {
      event.stopPropagation();
      event.preventDefault();
    }, options.visible && options.modal);
  };

  useEvent("mouseover");
  useEvent("mouseout");
}

var useDialog = createHook({
  name: "Dialog",
  compose: useDisclosureContent,
  useState: useDialogState,
  keys: ["hideOnEsc", "hideOnClickOutside", "preventBodyScroll", "unstable_initialFocusRef", "unstable_finalFocusRef", "unstable_orphan", "unstable_autoFocusOnShow", "unstable_autoFocusOnHide"],
  useOptions: function useOptions(_ref) {
    var _ref$modal = _ref.modal,
        modal = _ref$modal === void 0 ? true : _ref$modal,
        _ref$hideOnEsc = _ref.hideOnEsc,
        hideOnEsc = _ref$hideOnEsc === void 0 ? true : _ref$hideOnEsc,
        _ref$hideOnClickOutsi = _ref.hideOnClickOutside,
        hideOnClickOutside = _ref$hideOnClickOutsi === void 0 ? true : _ref$hideOnClickOutsi,
        _ref$preventBodyScrol = _ref.preventBodyScroll,
        preventBodyScroll = _ref$preventBodyScrol === void 0 ? modal : _ref$preventBodyScrol,
        _ref$unstable_autoFoc = _ref.unstable_autoFocusOnShow,
        unstable_autoFocusOnShow = _ref$unstable_autoFoc === void 0 ? true : _ref$unstable_autoFoc,
        _ref$unstable_autoFoc2 = _ref.unstable_autoFocusOnHide,
        unstable_autoFocusOnHide = _ref$unstable_autoFoc2 === void 0 ? true : _ref$unstable_autoFoc2,
        unstable_orphan = _ref.unstable_orphan,
        unstable_modal = _ref.unstable_modal,
        setModal = _ref.setModal,
        options = _objectWithoutPropertiesLoose(_ref, ["modal", "hideOnEsc", "hideOnClickOutside", "preventBodyScroll", "unstable_autoFocusOnShow", "unstable_autoFocusOnHide", "unstable_orphan", "unstable_modal", "setModal"]);

    useEffect(function () {
      if (setModal && unstable_modal !== modal) {
        process.env.NODE_ENV !== "production" ? warning(true, "Setting `modal` prop on `Dialog` is deprecated. Set it on `useDialogState` instead.", "See https://github.com/reakit/reakit/pull/535") : void 0;
        setModal(modal);
      }
    }, [setModal, unstable_modal, modal]);
    return _objectSpread2({
      modal: modal,
      hideOnEsc: hideOnEsc,
      hideOnClickOutside: hideOnClickOutside,
      preventBodyScroll: modal && preventBodyScroll,
      unstable_autoFocusOnShow: unstable_autoFocusOnShow,
      unstable_autoFocusOnHide: unstable_autoFocusOnHide,
      unstable_orphan: modal && unstable_orphan
    }, options);
  },
  useProps: function useProps(options, _ref2) {
    var htmlRef = _ref2.ref,
        htmlOnKeyDown = _ref2.onKeyDown,
        htmlWrapElement = _ref2.wrapElement,
        htmlProps = _objectWithoutPropertiesLoose(_ref2, ["ref", "onKeyDown", "wrapElement"]);

    var dialog = useRef(null);
    var backdrop = useContext(DialogBackdropContext);
    var disclosures = useDisclosuresRef(dialog, options);

    var _useNestedDialogs = useNestedDialogs(dialog, options),
        dialogs = _useNestedDialogs.dialogs,
        wrap = _useNestedDialogs.wrap;

    usePreventBodyScroll(dialog, options);
    useFocusTrap(dialog, dialogs, options);
    useFocusOnShow(dialog, dialogs, options);
    useFocusOnHide(dialog, disclosures, options);
    useHideOnClickOutside(dialog, disclosures, dialogs, options);
    useDisableHoverOutside(dialog, dialogs, options);
    var onKeyDown = useCallback(function (event) {
      if (event.key === "Escape" && options.hideOnEsc) {
        if (!options.hide) {
          process.env.NODE_ENV !== "production" ? warning(true, "`hideOnEsc` prop is truthy, but `hide` prop wasn't provided.", "See https://reakit.io/docs/dialog", dialog.current) : void 0;
          return;
        }

        event.stopPropagation();
        options.hide();
      }
    }, [options.hideOnEsc, options.hide]);
    var wrapElement = useCallback(function (element) {
      if (options.modal && !backdrop) {
        return createElement(Portal, null, wrap(element));
      }

      return wrap(element);
    }, [options.modal, backdrop, wrap]);
    return _objectSpread2({
      ref: useForkRef(dialog, htmlRef),
      role: "dialog",
      tabIndex: -1,
      onKeyDown: useAllCallbacks(onKeyDown, htmlOnKeyDown),
      wrapElement: usePipe(wrapElement, htmlWrapElement),
      "aria-modal": options.modal ? true : undefined,
      "data-dialog": true
    }, htmlProps);
  }
});
var Dialog = createComponent({
  as: "div",
  useHook: useDialog,
  useCreateElement: function useCreateElement$1(type, props, children) {
    process.env.NODE_ENV !== "production" ? useWarning(!props["aria-label"] && !props["aria-labelledby"], "You should provide either `aria-label` or `aria-labelledby` props.", "See https://reakit.io/docs/dialog") : void 0;
    return useCreateElement(type, props, children);
  }
});

export { Dialog, useDialog };
