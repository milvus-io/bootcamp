import 'react';
import './SystemContext.js';
import './useToken.js';
import { useProps } from './useProps.js';
import './_rollupPluginBabelHelpers-ce04ac6e.js';
import { useOptions } from './useOptions.js';
import { isObject } from 'reakit-utils/isObject';
import { toArray } from 'reakit-utils/toArray';

function deepEqual(objA, objB, depth) {
  if (depth === void 0) {
    depth = 1;
  }

  if (objA === objB) return true;
  if (!objA || !objB) return false;
  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var length = aKeys.length;
  if (bKeys.length !== length) return false;

  for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
    var key = _aKeys[_i];

    if (objA[key] !== objB[key]) {
      if (!depth || !isObject(objA[key]) || !isObject(objB[key]) || !deepEqual(objA[key], objB[key], depth - 1)) {
        return false;
      }
    }
  }

  return true;
}

/**
 * Creates a React custom hook that will return component props.
 *
 * @example
 * import { createHook } from "reakit-system";
 *
 * const useA = createHook({
 *   name: "A",
 *   keys: ["url"], // custom props/options keys
 *   useProps(options, htmlProps) {
 *     return {
 *       ...htmlProps,
 *       href: options.url
 *     };
 *   }
 * });
 *
 * function A({ url, ...htmlProps }) {
 *   const props = useA({ url }, htmlProps);
 *   return <a {...props} />;
 * }
 *
 * @param options
 */
function createHook(options) {
  var composedHooks = toArray(options.compose);

  var __useOptions = function __useOptions(hookOptions, htmlProps) {
    // Call the current hook's useOptions first
    if (options.useOptions) {
      hookOptions = options.useOptions(hookOptions, htmlProps);
    } // If there's name, call useOptions from the system context


    if (options.name) {
      hookOptions = useOptions(options.name, hookOptions, htmlProps);
    } // Run composed hooks useOptions


    if (options.compose) {
      composedHooks.forEach(function (hook) {
        hookOptions = hook.__useOptions(hookOptions, htmlProps);
      });
    }

    return hookOptions;
  };

  var useHook = function useHook(hookOptions, htmlProps, unstable_ignoreUseOptions) {
    if (hookOptions === void 0) {
      hookOptions = {};
    }

    if (htmlProps === void 0) {
      htmlProps = {};
    }

    if (unstable_ignoreUseOptions === void 0) {
      unstable_ignoreUseOptions = false;
    }

    // This won't execute when useHook was called from within another useHook
    if (!unstable_ignoreUseOptions) {
      hookOptions = __useOptions(hookOptions, htmlProps);
    } // Call the current hook's useProps


    if (options.useProps) {
      htmlProps = options.useProps(hookOptions, htmlProps);
    } // If there's name, call useProps from the system context


    if (options.name) {
      htmlProps = useProps(options.name, hookOptions, htmlProps);
    }

    if (options.compose) {
      if (options.useComposeOptions) {
        hookOptions = options.useComposeOptions(hookOptions, htmlProps);
      }

      if (options.useComposeProps) {
        htmlProps = options.useComposeProps(hookOptions, htmlProps);
      } else {
        composedHooks.forEach(function (hook) {
          htmlProps = hook(hookOptions, htmlProps, true);
        });
      }
    }

    return htmlProps;
  };

  if (process.env.NODE_ENV !== "production" && options.name) {
    Object.defineProperty(useHook, "name", {
      value: "use" + options.name
    });
  }

  useHook.__useOptions = __useOptions; // It's used by createComponent to split option props (keys) and html props

  useHook.__keys = [].concat(composedHooks.reduce(function (allKeys, hook) {
    allKeys.push.apply(allKeys, hook.__keys || []);
    return allKeys;
  }, []), options.useState ? options.useState.__keys : [], options.keys || []);
  var hasPropsAreEqual = Boolean(options.propsAreEqual || composedHooks.find(function (hook) {
    return Boolean(hook.__propsAreEqual);
  }));

  if (hasPropsAreEqual) {
    useHook.__propsAreEqual = function (prev, next) {
      var result = options.propsAreEqual && options.propsAreEqual(prev, next);

      if (result != null) {
        return result;
      }

      for (var _iterator = composedHooks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var hook = _ref;
        var propsAreEqual = hook.__propsAreEqual;
        var hookResult = propsAreEqual && propsAreEqual(prev, next);

        if (hookResult != null) {
          return hookResult;
        }
      } // @ts-ignore


      if (prev.children !== next.children) {
        return false;
      }

      return deepEqual(prev, next);
    };
  }

  return useHook;
}

export { createHook };
